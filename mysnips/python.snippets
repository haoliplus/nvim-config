priority 50

# vim:ft=snippets:
##########
# COMMON #
##########

# The smart def and smart class snippets use a global option called
# "g:ultisnips_python_style" which, if set to "doxygen" will use doxygen
# style comments in docstrings.

global !p

NORMAL  = 0x1
DOXYGEN = 0x2
SPHINX  = 0x3
GOOGLE  = 0x4
NUMPY   = 0x5
JEDI    = 0x6

SINGLE_QUOTES = "'"
DOUBLE_QUOTES = '"'


class Arg(object):
	def __init__(self, arg):
		self.arg = arg
		name_and_type = arg.split('=')[0].split(':')
		self.name = name_and_type[0].strip()
		self.type = name_and_type[1].strip() if len(name_and_type) == 2 else None

	def __str__(self):
		return self.name

	def __unicode__(self):
		return self.name

	def is_kwarg(self):
		return '=' in self.arg

	def is_vararg(self):
		return '*' in self.name


def get_args(arglist):
	args = []
	n = len(arglist)
	i = 0
	while i < n:
		l_bracket = 0
		start = i
		while i < n and (l_bracket > 0 or arglist[i] != ','):
			if arglist[i] == '[':
				l_bracket += 1
			elif arglist[i] == ']' and l_bracket > 0:
				l_bracket -= 1
			i += 1
		arg = arglist[start:i]
		if arg:
			args.append(Arg(arg))
		i += 1

	args = [arg for arg in args if arg.name != 'self']

	return args


def get_quoting_style(snip):
	style = snip.opt("g:ultisnips_python_quoting_style", "double")
	if style == 'single':
		return SINGLE_QUOTES
	return DOUBLE_QUOTES

def triple_quotes(snip):
	style = snip.opt("g:ultisnips_python_triple_quoting_style")
	if not style:
		return get_quoting_style(snip) * 3
	return (SINGLE_QUOTES if style == 'single' else DOUBLE_QUOTES) * 3

def triple_quotes_handle_trailing(snip, quoting_style):
	"""
	Generate triple quoted strings and handle any trailing quote char,
	which might be there from some autoclose/autopair plugin,
	i.e. when expanding ``"|"``.
	"""
	if not snip.c:
		# Do this only once, otherwise the following error would happen:
		# RuntimeError: The snippets content did not converge: â€¦
		_, col = vim.current.window.cursor
		line = vim.current.line

		# Handle already existing quote chars after the trigger.
		_ret = quoting_style * 3
		while True:
			try:
				nextc = line[col]
			except IndexError:
				break
			if nextc == quoting_style and len(_ret):
				_ret = _ret[1:]
				col = col+1
			else:
				break
		snip.rv = _ret
	else:
		snip.rv = snip.c

def get_style(snip):
	style = snip.opt("g:ultisnips_python_style", "normal")

	if    style == "doxygen": return DOXYGEN
	elif  style == "sphinx": return SPHINX
	elif  style == "google": return GOOGLE
	elif  style == "numpy": return NUMPY
	elif  style == "jedi": return JEDI
	else: return NORMAL


def format_arg(arg, style):
	if style == DOXYGEN:
		return "@param %s TODO" % arg
	elif style == SPHINX:
		return ":param %s: TODO" % arg
	elif style == NORMAL:
		return ":%s: TODO" % arg
	elif style == GOOGLE:
		return "%s (%s): TODO" % (arg, arg.type or "TODO")
	elif style == JEDI:
		return ":type %s: TODO" % arg
	elif style == NUMPY:
		return "%s : TODO" % arg


def format_return(style):
	if style == DOXYGEN:
		return "@return: TODO"
	elif style in (NORMAL, SPHINX, JEDI):
		return ":returns: TODO"
	elif style == GOOGLE:
		return "Returns: TODO"


def write_docstring_args(args, snip):
	if not args:
		snip.rv += ' {0}'.format(triple_quotes(snip))
		return

	snip.rv += '\n' + snip.mkline('', indent='')

	style = get_style(snip)

	if style == GOOGLE:
		write_google_docstring_args(args, snip)
	elif style == NUMPY:
		write_numpy_docstring_args(args, snip)
	else:
		for arg in args:
			snip += format_arg(arg, style)


def write_google_docstring_args(args, snip):
	kwargs = [arg for arg in args if arg.is_kwarg()]
	args = [arg for arg in args if not arg.is_kwarg()]

	if args:
		snip += "Args:"
		snip.shift()
		for arg in args:
			snip += format_arg(arg, GOOGLE)
		snip.unshift()
		snip.rv += '\n' + snip.mkline('', indent='')

	if kwargs:
		snip += "Kwargs:"
		snip.shift()
		for kwarg in kwargs:
			snip += format_arg(kwarg, GOOGLE)
		snip.unshift()
		snip.rv += '\n' + snip.mkline('', indent='')


def write_numpy_docstring_args(args, snip):
	if args:
		snip += "Parameters"
		snip += "----------"

	kwargs = [arg for arg in args if arg.is_kwarg()]
	args = [arg for arg in args if not arg.is_kwarg()]

	if args:
		for arg in args:
			snip += format_arg(arg, NUMPY)
	if kwargs:
		for kwarg in kwargs:
			snip += format_arg(kwarg, NUMPY) + ', optional'
	snip.rv += '\n' + snip.mkline('', indent='')


def write_init_body(args, parents, snip):
	parents = [p.strip() for p in parents.split(",")]
	parents = [p for p in parents if p != 'object']

	for p in parents:
		snip += p + ".__init__(self)"

	if parents:
		snip.rv += '\n' + snip.mkline('', indent='')

	for arg in filter(lambda arg: not arg.is_vararg(), args):
		snip += "self._%s = %s" % (arg, arg)


def write_slots_args(args, snip):
	quote = get_quoting_style(snip)
	arg_format = quote + '_%s' + quote
	args = [arg_format % arg for arg in args]
	snip += '__slots__ = (%s,)' % ', '.join(args)


def write_function_docstring(t, snip):
	"""
	Writes a function docstring with the current style.

	:param t: The values of the placeholders
	:param snip: UltiSnips.TextObjects.SnippetUtil object instance
	"""
	snip.rv = ""
	snip >> 1

	args = get_args(t[2])
	if args:
		write_docstring_args(args, snip)

	style = get_style(snip)

	if style == NUMPY:
		snip += 'Returns'
		snip += '-------'
		snip += 'TODO'
	else:
		snip += format_return(style)
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += triple_quotes(snip)

def get_dir_and_file_name(snip):
	return os.getcwd().split(os.sep)[-1] + '.' + snip.basename

endglobal

###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################

#! header
snippet ifx "if __main__" b
if __name__ == `!p snip.rv = get_quoting_style(snip)`__main__`!p snip.rv = get_quoting_style(snip)`:
	${1:${VISUAL:main()}}
endsnippet

snippet initlogger "init logger" b
import sys
import logging
from pathlib import Path

def init_logger(
		base_name="temp.log", log_dir=Path.home() / ".cache" / "log", reset=True
):
		if len(base_name) == 0:
				base_name = "temp.log"
		if Path(base_name).suffix != ".log":
				base_name = f"{Path(base_name).stem}.log"

		base_path = base_name
		if base_name[0] != "/":
				base_path = log_dir / base_name

		Path(base_path).parent.mkdir(parents=True, exist_ok=True)
		log_file_path = base_path
		cnt = 0
		while Path(log_file_path).exists():
				cnt += 1
				log_file_path = f"{base_path}.{cnt}"

		stream_handler = logging.StreamHandler(sys.stdout)
		stream_handler.setLevel(logging.INFO)
		file_handler = logging.FileHandler(log_file_path)
		file_handler.setLevel(logging.DEBUG)
		logger = logging.getLogger()
		if reset:
				logger.handlers.clear()

		logging.basicConfig(
				level=logging.DEBUG,
				datefmt="%m-%d %H:%M:%S",
				format="[%(threadName) %(asctime)s.%(msecs)03d %(filename)s:%(lineno)d] [%(levelname)s] %(message)s",
				handlers=[stream_handler, logging.FileHandler(log_file_path)],
		)
		logger.info(f"Logging into {log_file_path}")
		logger.debug(f"Logging debug {log_file_path}")
		return logging
endsnippet

snippet ldproto "load proto" b
from google.protobuf import text_format
text_format.Parse(open(path, "r").read(), obj)
endsnippet

snippet ts2dt "float timestamp(second) to datetime" b
from datetime import datetime
dt_object = datetime.fromtimestamp(${1})
endsnippet

snippet dt2ts "datetime to float timestamp(second)" b
from datetime import datetime
dt = datetime(year=${1}, month=${2}, day=${3})
ts = datetime.timestamp(dt)
endsnippet

snippet strptime "parse datetime" b
from datetime import datetime
datetime.strptime("2021-01-02 10:00:00.123", "%Y-%m-%d %H:%M:%S.%f")
endsnippet

snippet strftime "format datetime" b
from datetime import datetime
now = datetime.now()
now.strftime("%Y-%m-%d %H:%M:%S.%f")
endsnippet

snippet jsonencoder "some to json" b
import json
import numpy as np
from datetime import datetime
from bson import ObjectId
class CustomEncoder(json.JSONEncoder):
	# json.dumps(data, cls=CustomEncoder)
	def default(self, obj):
		if isinstance(obj, np.integer):
			return int(obj)
		if isinstance(obj, np.floating):
			# alternatively use str()
			return float(obj)
		if isinstance(obj, np.ndarray):
			return obj.tolist()
		if isinstance(obj, datetime):
			return str(obj)
		if isinstance(obj, ObjectId):
			return str(obj)
		return json.JSONEncoder.default(self, obj)

json.dumps(obj, indent=2, cls=CustomEncoder))
endsnippet

snippet asyncmp "async multi process" b
import multiprocessing as mp

def task(slice, shared_data):
	pass

n_worker = 8
pool = mp.Pool(n_worker)
result_list = []
inp_list = [1, 2, 3, 4]
num = len(inp_list)
shared_data = None
num_slice = num // n_worker
for i in range(n_worker):
		tmp = inp_list[num_slice * i : num_slice * (i + 1)]
		result_list.append(pool.apply_async(task, args=(tmp[:], shared_data)))
pool.close()
pool.join()

results = [result.get() for result in result_list]
endsnippet
snippet multithread "async multi thread" b
import threading
class MyThread(threading.Thread):
	def run(self):
		pass

for f in range(4):
	t = MyThread()
	t.start()
	t.join()
endsnippet
